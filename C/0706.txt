피드백

1. for문
별표 문제
띄어쓰기는 +로 표시

5입력했을때
*****
+****
++***
+++**
++++*

#include <stdio.h>

int main() {

	int n;
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n;j++) {	
			if (j < i) {
				printf(" ");
			}
			else {
				printf("*");
			}

		}
		
		printf("\n");
	}
	
	return 0;
}


+++++


<문제풀이 순서>
1. 독해
2. 문제풀이
3. 코드로 옮기기


요리 제작
트라하를 즐기는 아란은 전문 기술 중 요리 제작에 푹 빠져 있다. 특히 스테이크를 좋아하는 아란은 주어진 재료로 최대한 많은 스테이크를 만들고 싶다.
스테이크를 만들 때는 필요한 재료 수가 적혀 있는 레시피가 필요하다. 레시피에 쓰여있는 양 만큼의 재료를 창고에서 꺼내어서 요리하면 스테이크를 한 개 만들 수 있다. 재료 중 하나라도 모자란 경우 스테이크를 만들 수 없으며, 스테이크는 한 개 단위로만 만들 수 있다. 즉, 재료의 일부만 써서 스테이크를 일부만 만들 수는 없다.
필요한 재료 수가 적혀 있는 스테이크의 레시피와 창고에 있는 재료의 수가 주어질 때, 최대 몇 개의 스테이크를 만들 수 있는지 구하여라.
입력 형식
첫째 줄에 재료의 가짓수 N이 주어진다. (1 ≤ N ≤ 100)
둘째 줄에는 N개의 정수가 공백으로 구분되어 주어지는데, 그중 i번째 수는 창고에 있는 i번째 재료의 개수를 의미한다. 이때, 주어지는 수는 0 이상 100 이하이다.
셋째 줄에는 N개의 정수가 공백으로 구분되어 주어지는데, 그중 i번째 수는 스테이크를 만드는데 필요한 i번째 재료의 개수이다. 이때, 주어지는 수는 0 이상 100 이하이다.
요리를 만들 때 적어도 하나의 재료가 필요하다는 것이 보장된다.
출력 형식
첫째 줄에 만들 수 있는 스테이크의 최대 개수를 출력한다.
입력 예제 1
3
6 3 5
1 1 2
출력 예제 1
2
입력 예제 2
2
100 0
1 1
출력 예제 2
0

#include<stdio.h>
int main() {

	int n;
	scanf("%d", &n);
	int a[100];
	int b[100];
	for (int i = 0; i < n; i++) {
		scanf("%d", &a[i]);
	}
	for (int i = 0; i < n; i++) {
		scanf("%d", &b[i]);
	}
	int cnt = 0;
	int sw = 0; // OFF
	while (1) {
		for (int i = 0; i < n; i++) {
			a[i] -= b[i];
			if (a[i] < 0) {
				sw = 1; // ON
			}
		}
		if (sw == 1) {
			break;
		}
		cnt++;
	}
	printf("%d", cnt);

	return 0;
}


+++++


최대 HP
당신은 게임 "마비노기 영웅전"의 전투 로그 분석을 맡게 되었다. 이번에 분석할 전투는 마법 전문가인 이비의 전투이다.
이비는 몬스터와 전투를 했고, 이 때 전투 과정에서 발생하는 게임 로그인 전투 로그는 시작 체력과 여러 개의 턴으로 이루어져 있다. 그리고 각 턴 마다 다음의 로그가 한 줄에 하나씩 기록되어있다.
? 이비가 데미지를 받는다. 이 턴 이후에 체력이?h?만큼 줄어든다. 단, 데미지를 받아서 체력이 0 이하가 되는 경우는 없었다. 이 로그는?1 h?형태로 기록된다.
? 이비가 "회복" 스킬을 사용한다. 이 턴 이후에 체력이?h만큼 회복된다. 단, 회복을 해서 최대 체력을 넘어가는 경우는 없었다. 이 로그는?2 h?형태로 기록된다.
? 이비가 "최대 생명력" 스킬을 사용한다. 이 턴 이후에 체력이?h만큼 회복되어 최대 체력이 된다. 이 로그는?3 h?형태로 기록된다.
이비의 최대 체력은 처음부터 정해져 있으며 변하지 않았다. 이 로그들을 분석하여 이비의 최대 체력이 얼마인지 알아보자.
입력 형식
첫째 줄에 시작 체력 H와 진행한 턴 수 T가 공백으로 구분되어 주어진다. (1 ≤ H ≤ 100; 3 ≤ T ≤ 100)
다음 T개의 줄에는 로그의 종류를 뜻하는 a, 데미지의 양 혹은 회복된 양을 뜻하는 h가 공백으로 구분되어 주어진다. 로그에 대한 설명은 본문과 같다. (1 ≤ a ≤ 3; 1 ≤ h ≤ 100)
입력으로 주어지는 모든 수는 자연수이고, 모든 로그는 올바르다는 것이 보장되며, 각 종류의 로그가 최소 한 개 이상 들어온다는 것이 보장된다.
출력 형식
분석한 이비의 최대 체력을 첫째 줄에 출력한다.
입력 예제
10 3
2 20
1 10
3 40
출력 예제
60

/*
20 3
3 30 -> 50
1 40
2 10
-----
50 (20 xxx)
*/
#include<stdio.h>
int main() {

	int h, t;
	scanf("%d%d", &h, &t);
	int act, x;
	int max = h;
	for (int i = 0; i < t; i++) {
		scanf("%d%d", &act, &x);
		if(act==1){
			h -= x;
		}
		else if (act == 2) {
			h += x;
			if (max < h) {
				max = h;
			}
		}
		else {
			h += x;
			if (max < h) {
				max = h;
			}
		}
	}
	printf("%d", max);

	return 0;
}


+++++


배열 정렬
왜? 탐색을 유리하게 만들도록 사전에 실시하는것이 정렬이다!

버블정렬(거품정렬)
오름차순

#include <stdio.h>

int main() {

	int arr[5] = { 2,4,1,3,5 };
	for(int j=0;j<5;j++){	//아래의 비교를 [데이터개수]번 수행
		for (int i = 0; i < 5-1; i++) {	// [데이터 개수 -1] 번 비교수행
			if (arr[i] > arr[i + 1]) {
				//교환수행!
				int tmp = arr[i];	//임시저장변수
				arr[i] = arr[i + 1];
				arr[i + 1] = tmp;
			}
		}
	}
	for (int i = 0; i < 5; i++) {
		printf("%d ", arr[i]);
	}

	return 0;
}


+++++


경진대회

10 3 -> 8번 비교 3~10
5 2 -> 4번 비교 2~5
5 3 -> 3번 비교 3~5
1 1 1 1 1 1
/*6 3 ->4  3~6
a-b*/


#include<stdio.h>
int main() {

	int a, b;
	scanf("%d%d", &a, &b);
	int arr[1000];
	for (int i = 0; i < a; i++) {
		scanf("%d", &arr[i]);
	}
	int max = 0;
	int sum = 0;
	for (int i = 0; i < a - b + 1; i++) {
		sum = 0; // 초기화자리
		for (int j = 0; j < b; j++) {
			// 더하기 수행
			sum += arr[i + j];
			/*
			i=0,j=0 [0]
			i=0,j=1 [1]
			i=0,j=2 [2]

			i=1,j=0 [1]
			i=1,j=1 [2]
			i=1,j=2 [3]

			i=2,j=0 [2]
			i=2,j=1 [3]
			i=2,j=2 [4]
			*/
		}
		if (sum > max) {
			max = sum;
		}
	}
	printf("%d", max);

	return 0;
}

-------------

#include <stdio.h>

int main() {
	
	int a, b;
	scanf("%d%d", &a, &b);
	int data[1000];
	for (int i = 0; i < a; i++) {
		scanf("%d", &data[i]);
	}
	/*int max = data[0] + data[1] + data[2];
	
	for (int i = b - 1; i < a-2; i++) { //a-b+1번만큼 진행된다 int i=0;i<a-b;i++
		if (max < data[i] + data[i + 1] + data[i + 2]) {
			max = data[i] + data[i + 1] + data[i + 2];
		}
	}*/
	int sum = 0;
	for (int i = 0; i < a - b + 1; i++) {
		for (int j = 0; j < b; j++) {
			//더하기 수행
			sum += data[i + j];
		}
		if (sum > max) {
			max == sum;
		}
	}
	printf("%d", max);
	return 0;
}






















